# 集合




集合、容器
1. 概述
2. 列表
3. 链表
4. 集合
5. 字典
6. 排序列表
7. 排序集合
8. 排序字典
9. 堆栈
10. 队列
11. 点列阵

## 一、集合概述

>对于许多应用程序，你会想要创建和管理相关对象的组。 有两种方法对对象进行分组：通过创建对象的数组，以及通过创建对象的集合。

数组最适用于创建和使用固定数量的强类型化对象。与数组不同，集合提供更灵活的方式来使用对象组，你使用的对象组随着应用程序更改的需要**动态地放大和缩小**。 

集合是专门被设计用来存储和检索数据的**类**，这些集合类是 .NET 框架提供的。.NET 早期在 `System.Collection` 命名空间下提供了一些集合类，但它们不是类型安全的，该命名空间中的类不会将元素作为特别类型化的对象存储，而是作为 `Object` 类型的对象存储。

随着版本迭代，.NET 提供了泛型集合，位于 `System.Collection.Generic` 命名空间下， 泛型集合强制类型安全，因此无法向其添加任何其他数据类型。 当你从泛型集合检索元素时，你无需确定其数据类型或对其进行转换。

为了实现多线程下的安全访问，`System.Collection.Concurrent` 命名空间下提供了并发安全的集合类。

!!! Warning
	应尽可能地使用 `System.Collections.Generic` 命名空间或 `System.Collections.Concurrent` 命名空间中的泛型集合，而不是 `System.Collections` 命名空间中的旧类型。

!!! Note
	通用集合类入口：<br>
	:link: [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic)  <br>
	:link: [System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent)  <br>
	:link: [System.Collections](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections) 

本节内容将介绍一些常用的泛型集合类以及简单使用，对于非泛型集合类作了解补充。主要涉及的泛型类有：

| 类              | 说明                               |
|:--------------- |:---------------------------------- |
| List<T\>       | 列表，自适应大小的数组集合         |
| Dictionary<K,V\> | 键值集合，按键值对存储的集合       |
| HashSet<T\>     | 集，不允许重复元素的数组集合     |
| SortedList<K,V\> | 排序键值列表，根据自定义排序规则实现按键排序的键值对集合 |
| Stack<T\>       | 栈，先进后出的数据结构             |
| Queue<T\>       | 队列，先进先出的数据结构           |
| BitArray        | 点列阵，存储二进制的紧缩数组       | 


## 二、列表
数组（array）在声明时通常会指定大小，而一旦确定后，数组大小就无法改变了。为了满足更加灵活的应用场景，因此定义了动态数组，也可称列表（List）。List 是可以自动调整大小的数据结构，并且允许在列表中进行动态内存分配、增加、搜索、排序等操作。

#### .NET类
`List<T>` 是 .NET System.Collections.Generic 中提供的类型安全的泛型列表，它替代了早期版本 System.Collections 中定义的 `ArrayList`，当你需要使用动态容量的集合存储数据时，你可以考虑它：

1. 当存储的对象具有同质类型时，应当使用 `List<T>`，`T` 为同质类型；
2. 当存储的对象具有不同类型时，应当使用 `List<Object>` 。

!!! Note
	List<T\> / ArrayList 具有一下特点：<br>
	:one: 元素无序性。存储的元素是无序的，它们只按添加的顺序指派索引，需要排序输出请使用Sort方法。<br>
	:two: 允许存储重复元素。列表允许重复添加同一元素。<br>
	:three: 允许存储 null 。列表允许添加 `null` ，并且允许多次添加。<br>
	:four: 非线程安全的。执行多次读取操作是安全的，但如果在读取时修改集合，则会出现问题。

!!! Danger
	为了确保线程安全，在读或写操作期间锁定集合。要使一个集合能够被多个线程访问以进行读写，您必须实现自己的同步。对于内置同步的集合，请参阅 System.Collections.Concurrent 命名空间中的类。有关固有的线程安全替代方法，请参阅 ImmutableList<T\>类。

#### 继承体系：
=== "List<T\>"
	```csharp
	public class List<T> : 
	    System.Collections.Generic.ICollection<T>, 
	    System.Collections.Generic.IEnumerable<T>, 
	    System.Collections.Generic.IList<T>, 
	    System.Collections.Generic.IReadOnlyCollection<T>, 
	    System.Collections.Generic.IReadOnlyList<T>, 
	    System.Collections.IList
	```

=== "ArrayList"
	```csharp
	public class ArrayList : ICloneable, System.Collections.IList
	```

#### 基本使用
=== "List<T\>"
	```csharp
	/* 定义一个方法用来输出 */
	private static void Print(string log, List<string> list)
	{
		Console.Write(log + ":");
		list.ForEach(x => Console.Write(x));
		Console.WriteLine();
	}
	private static void Main(string[] args)
	{
		// 实例化
		List<string> list = new List<string>();
		// 添加
		list.Add("A");
		list.Add("B");
		list.Add("C");
		list.Add("D");
		list.Add("E");
		list.Add("F");
		list.Add("G");
		// 属性
		Console.WriteLine(list.Capacity);
		Console.WriteLine(list.Count);
		// 遍历
		Console.Write("遍历：");
		foreach (String s in list)
			Console.Write(s);
		Console.WriteLine();
		// 索引
		Console.WriteLine("索引：" + list[5]);
		// 移除
		list.Remove("G");
		Print("根据元素移除", list);
		list.RemoveAt(0);
		Print("根据索引移除", list);
		// 反转
		list.Reverse();
		Print("反转", list);
		// 清空
		list.Clear();
		Print("清空", list);
	}
	// Output:
	// 8
	// 7
	// 遍历：ABCDEFG
	// 索引：F
	// 根据元素移除:ABCDEF
	// 根据索引移除:BCDEF
	// 反转:FEDCB
	// 清空:
	```

=== "ArrayList"
	```csharp
	/* 定义一个打印的方法（注：foreach 中的使用的object类型）*/
	private static void Print(string log, ArrayList list)
	{
		Console.Write(log + ":");
		foreach (object o in list)
		{
			Console.Write(o.ToString());
		}
		Console.WriteLine();
	}
	private static void Main(string[] args)
	{
		// 实例化
		ArrayList list = new ArrayList();
		// 添加
		list.Add("A");
		list.Add("B");
		list.Add("C");
		list.Add(1);
		list.Add(2);
		list.Add(3);
		list.Add(true);
		// 属性
		Console.WriteLine(list.Capacity);
		Console.WriteLine(list.Count);
		// 遍历
		Console.Write("遍历：");
		foreach (object o in list)
			Console.Write(o);
		Console.WriteLine();
		// 索引
		Console.WriteLine("索引：" + list[5]);
		// 移除
		list.Remove("True");
		Print("根据元素移除", list);
		list.RemoveAt(0);
		Print("根据索引移除", list);
		// 反转
		list.Reverse();
		Print("反转", list);
		// 清空
		list.Clear();
		Print("清空", list);
	}
	// Output:
	// 8
	// 7
	// 遍历：ABC123True
	// 索引：3
	// 根据元素移除:ABC123True
	// 根据索引移除:BC123True
	// 反转:True321CB
	// 清空:
	```


## 三、键值集合
键值集合通过键值对来维护元素，Key 与 Vlaue 成对出现。

#### .Net类
`Dictionary<TKey,TValue>` 是 .NET System.Collections.Generic 中提供的保存键值元素的集合，它替代了早期 System.Collections 中的 `Hashtable` 。当你需要使用一组键到一组值的映射时，可以考虑使用该类型。

字典中的每一个添加项都由一个值及其关联键组成。通过键检索值非常快，接近于O(1)，因为Dictionary 类被实现为哈希表。

!!! Note
	Dictionary<TKey,TValue\> 具有一下特点：<br>
	:one: 元素无序性。存储的元素是无序的，字典根据元素添加的顺序存储元素。<br>
	:two: Key 不能相同，但 Value 可以。字典通过相等比较器确保每个键都是唯一的，只要一个对象被用作键，它就不能以任何影响其哈希值的方式改变。<br>
	:three: Key 不能为 null，但 Value 可以。如果类型 TValue 是引用类型，那么它可以取 null，但键不可以。<br>
	:four: 非线程安全的。执行多次读取操作是安全的，但如果在读取时修改集合，则会出现问题。

!!! Tip
	尽管 Hashtable 是线程安全的，但仍不建议使用它，有关线程安全的替代，请参阅 [ConcurrentDictionary<TKey,TValue\>](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2?view=net-7.0) 类或 [ImmutableDictionary<TKey,TValue\>](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.immutable.immutabledictionary-2?view=net-7.0) 类。

为了便于枚举，字典中的每一项都被视为表示值及其键的 [KeyValuePair<TKey,TValue\>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair?view=net-7.0) 结构。返回项的顺序未定义。由于Dictionary 是键和值的集合，因此元素类型既不是键的类型也不是值的类型。相反，元素类型是键类型和值类型的 KeyValuePair ，你可以在遍历时用到这个类型。

#### 继承体系
=== "Dictionary"
	```csharp
	public class Dictionary<TKey,TValue> : 
	System.Collections.Generic
		.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
		.IDictionary<TKey,TValue>, 
		.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
		.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
		.IReadOnlyDictionary<TKey,TValue>, 
	System.Collections.IDictionary, System.Runtime.Serialization
		.IDeserializationCallback, 
		.ISerializable
	```

=== "Hashtable"
	```csharp
	public class Hashtable : 
		ICloneable, 
		System.Collections.IDictionary,
		System.Runtime.Serialization.IDeserializationCallback,
		System.Runtime.Serialization.ISerializable
	```

#### 基本使用
=== "Dictionary"


=== "Hashtable"

## 四、集
集（Set）和列表类似，它也可以存储一组元素，与 List 不同的是，Set 不允许重复元素且无法索引。它与数学概念中的集合一致。

#### .NET 类
`HashSet<T>` 是 .NET System.Collections.Generic 中提供的保存非重复元素的集合，在 System.Collcetion 中没有类似的类。

HashSet 类基于数学集模型，提供了高性能的集合操作，如交集、并集、差集等。Set 是不包含重复元素的集合，其元素没有特定的顺序。HashSet 类提供了类似于访问 Dictionary 或 Hashtable 集合的键的高性能集操作。简单来说，HashSet 类可以看作是一个没有值的 Dictionary 集合。

!!! Note
	HashSet 具有一下特点：<br>
	:one: 元素无序性。存储的元素是无序的，并且没有**不能通过索引器获取元素**。<br>
	:two: 不能存储重复元素。该集合不会将一个已经存在的元素再次存储到集合中。<br>
	:three: 允许存储 null 。该集合允许存储 null，但只会存储一次。<br>
	:four: 非线程安全的。

!!! tip
	HashSet 集合没有排序，不能包含重复的元素。对于应用程序，如果顺序或元素复制比性能更重要，请考虑将List 类与 Sort 方法结合使用。

#### 继承体系
```csharp
public class HashSet<T> : 
	System.Collections.Generic.ICollection<T>, 
	System.Collections.Generic.IEnumerable<T>, 
	System.Collections.Generic.IReadOnlyCollection<T>, 
	System.Collections.Generic.IReadOnlySet<T>, 
	System.Collections.Generic.ISet<T>, 
	System.Runtime.Serialization.IDeserializationCallback, 
	System.Runtime.Serialization.ISerializable
```

#### 基本使用
=== "HashSet"

## 五、排序列表

## 六、排序字典

## 七、排序集

## 八、栈

## 九、队列

## 十、点列阵



#### 定义
Hashtable 类代表了一系列基于 **键的哈希代码** 组织起来的**键/值**对，使用 **键** 来访问集合中的元素。

#### 继承体系
```csharp
public class Hashtable : 
	ICloneable, 
	System.Collections.IDictionary,
	System.Runtime.Serialization.IDeserializationCallback,
	System.Runtime.Serialization.ISerializable
```

#### 特点
1. Hashtable 是无序的，根据添加顺序存储；
2. Hashtable 的 Key 不允许为 `null`，但 Value 可以；
3. Hashtable 的 Key 不允许重复，但不同键的 Value 可以；
4. Hashtable 是 ==线程安全的== ，可供多个读取器线程和单个写入线程使用。


#### 操作
下面为集合的遍历、添加元素、移除元素等基本操作，更过 API 指路：[Hashtable API](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable?view=net-7.0) 。

=== "实例化"

=== "遍历"

=== "添加"

=== "移除"

### 02 Dictionary<K, V\>
#### 定义


#### 继承体系
```csharp
public class Dictionary<TKey,TValue> : 
System.Collections.Generic
	.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IDictionary<TKey,TValue>, 
	.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IReadOnlyDictionary<TKey,TValue>, 
System.Collections.IDictionary, System.Runtime.Serialization
	.IDeserializationCallback, 
	.ISerializable
```

#### 特点
`Dictionary<K, V>` ==不是线程安全的== ，在遍历与写入访问相争的极少数情况下，必须在整个枚举期间锁定集合。 若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。

有关线程安全的替代，请参阅 [ConcurrentDictionary<TKey,TValue>](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2?view=net-7.0) 类或 [ImmutableDictionary<TKey,TValue>](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.immutable.immutabledictionary-2?view=net-7.0) 类。

#### 操作
下面为集合的遍历、添加元素、移除元素等基本操作，更过 API 指路：。

=== "实例化"

=== "遍历"
	```csharp
	foreach( KeyValuePair<string, string> kvp in myDictionary )
	{
	    Console.WriteLine("Key = {0}, Value = {1}", kvp.Key, kvp.Value);
	}
	```
=== "添加"

=== "移除"



!!! Danger
	foreach 语句只允许从集合读取，不允许在遍历时对集合进行增删改。


## 三、排序键值集合
### 01 SortedList
#### 定义
SortedList 也是使用键值存储元素的集合，这些键值对 **按键排序** 并可按照键和索引访问。

索引序列基于排序序列。 添加元素时，它将按正确的排序顺序插入到 中 SortedList，索引会相应地调整。 删除元素时，索引也会相应地进行调整。 因此，在对象中添加或移除元素时，特定键/值对的 SortedList 索引可能会更改。

#### 继承体系
```csharp
public class SortedList : ICloneable, System.Collections.IDictionary
```

#### 特点
1. SortList 对象内部通过两个数组来维护元素，一个用于键，一个用于关联值；
2. SortList 的键不能为 `null` ，但值可以；
3. SortList 的键不允许重复，但不同键的值可以相等；
4. 由于需要进行排序，SortList 比 Hashtable 慢，但是灵活性更高；
5. 集合的每个元素都是可作为 DictionaryEntry 对象访问的键/值对。

!!! Tip
	不建议使用 `SortedList` 类进行新的开发。 建议改用泛型System.Collections.Generic.SortedList<TKey,TValue> 类。

#### 操作
下面为集合的遍历、添加元素、移除元素等基本操作，更过 API 指路：。

=== "实例化"

=== "遍历"
	```csharp
	foreach (DictionaryEntry de in mySortedList)
	{
	    //...
	}
	```
=== "添加"

=== "移除"

### 02 SortedList<K，V\>
#### 定义
表示基于相关的 [IComparer<T\>](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icomparer-1?view=net-7.0) 实现按键进行排序的键/值对的集合。

#### 继承体系
```csharp
public class SortedList<TKey,TValue> : 
System.Collections.Generic
	.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IDictionary<TKey,TValue>, 
	.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>, 
	.IReadOnlyDictionary<TKey,TValue>, 
System.Collections.IDictionary
```

#### 特点
1. SortedList<K，V> 实现为键/值对数组，按键排序，每个元素都可以作为 KeyValuePair<K，V> 对象进行检索；
2. SortedList<K，V> 键允许不能为 null，但值可以；
3. SortedList<K，V> 键不能重复，但不同键的值可以
4. SortedList<K，V> 不是线程安全的。

SortedList<K，V> 只要集合未修改，就可以同时支持多个读取器。 即便如此，通过集合枚举本质上也不是线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。 若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。

#### 操作
=== "实例化"

=== "遍历"
	```csharp
	foreach( KeyValuePair<int, string> kvp in mySortedList )
	{
	    Console.WriteLine("Key = {0}, Value = {1}", kvp.Key, kvp.Value);
	}
	```
=== "添加"

=== "移除"


## 四、堆栈
### 01 Stack
#### 定义
非泛型的栈结构，元素按照先进后出（FILO）原则存取。

#### 继承体系
```csharp
public class Stack : ICloneable, System.Collections.ICollection
```

#### 特点
1. Stack 结构先进后出；
2. Stack 是非泛型的，因此元素按 Object 类型；
3. Stack 允许 null 值，允许重复元素；
4. Satck 不是线程安全的。

为了保证Stack的线程安全，所有操作都必须通过Synchronized(Stack)方法返回的包装器来完成。  

枚举集合本质上不是线程安全的过程。即使在同步集合时，其他线程仍然可以修改集合，这将导致枚举器抛出异常。为了保证枚举期间的线程安全，您可以在整个枚举期间锁定集合，或者捕获由其他线程所做的更改所导致的异常。

#### 操作
=== "实例化"

=== "遍历"

=== "添加"

=== "移除"

### 02 Stack<T\>
#### 定义
栈结构的泛型类型，元素类型应为 `T` 或 派生自 `T`。

#### 继承体系
```csharp
public class Stack<T> : 
	System.Collections.Generic.IEnumerable<T>, 
	System.Collections.Generic.IReadOnlyCollection<T>, 
	System.Collections.ICollection
```

#### 特点
1. Stack<T\> 结构先进后出；
2. Stack<T\> 是非泛型的，因此元素按 Object 类型；
3. Stack<T\> 允许 null 值，允许重复元素；
4. Stack<T\> 不是线程安全的。

只要不修改集合，Stack<T\> 就可以同时支持多个读取器。即便如此，通过集合进行枚举本质上也不是线程安全的过程。若要保证枚举期间的线程安全，可以在整个枚举期间锁定集合。若要允许多个线程访问集合以进行读取和写入，必须实现自己的同步。

#### 操作
=== "实例化"

=== "遍历"

=== "添加"

=== "移除"


## 五、队列
### 01 Queue
#### 定义
非泛型的队列结构，元素按照先进先出（FIFO）原则存取。

#### 继承体系
```csharp
public class Queue : ICloneable, System.Collections.ICollection
```

#### 特点
1. Queue 结构只能从一端插入，从另一端删除，因此是先进先出的；
2. Queue 通过容量因子来完成扩容，新容量 = 容量因子 * 当前容量，容量因子默认为 2.0；
3. Queue 允许 `null` 和重复元素；
4. Queue 不是线程安全的。

为了保证Queue的线程安全，所有操作都必须通过Synchronized(Queue)方法返回的包装器来完成。  

枚举集合本质上不是线程安全的过程。即使在同步集合时，其他线程仍然可以修改集合，这将导致枚举器抛出异常。为了保证枚举期间的线程安全，您可以在整个枚举期间锁定集合，或者捕获由其他线程所做的更改所导致的异常。

!!! Tip
	当您可能希望在检索元素的值后丢弃该元素时。如果需要按照信息在集合中的存储顺序访问信息，请使用队列。如果希望以相反顺序访问信息，请使用堆栈。

#### 操作
=== "实例化"

=== "遍历"

=== "添加"

=== "移除"


### 02 Queue<T\>
#### 定义
非泛型的队列结构，元素按照先进先出（FIFO）原则存取。

#### 继承体系
```csharp
public class Queue<T> : 
	System.Collections.Generic.IEnumerable<T>, 
	System.Collections.Generic.IReadOnlyCollection<T>, 
	System.Collections.ICollection
```

#### 操作
Queue<T\>可以同时支持多个读取器，只要集合未被修改。即便如此，对集合进行枚举本质上也不是线程安全的过程。有关线程安全队列，请参见ConcurrentQueue<T\>。



## 六、点列阵
### 01 定义
它代表了一个使用值 1 和 0 来表示的**二进制**数组。

当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。

BitArray 类管理一个紧凑型的位值数组，它使用布尔值来表示，其中 true 表示位是开启的（1），false 表示位是关闭的（0）。

当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。

### 02 继承体系
```csharp
public sealed class BitArray : ICloneable, System.Collections.ICollection
```

### 03 特点
1. BitArray 的容量始终与元素个数相同；
2. BitArray 具有与其他集合不同的方法，这些方法用于完成逻辑运算；
3. BitArray 通过 Length 属性完成元素的增加和删除；
4. BitArray 允许重复元素，但不允许 `null` ；
5. BitArray 不是线程安全的；

这个实现没有为BitArray提供同步的(线程安全的)包装器。  

枚举集合本质上不是线程安全的过程。即使在同步集合时，其他线程仍然可以修改集合，这将导致枚举器抛出异常。为了保证枚举期间的线程安全，您可以在整个枚举期间锁定集合，或者捕获由其他线程所做的更改所导致的异常。

### 04 操作

## 七、总结

集合
类
说明
泛型类
重复元素
可null值
线程安全

|                | 动态数组          | 键值集合                                              | 排序列表             | 堆栈         | 队列                | 点阵列            |
|:-------------- |:----------------- |:----------------------------------------------------- |:-------------------- |:------------ |:------------------- | ----------------- |
| **类**         | ArrayList         | Hashtable                                             | SortedList           | Stack        | Queue               | BitArray          |
| **泛型类**     | List<T\>          | Dictionary<K,V>                                       | SortedList<K,V>      | Stack<T\>    | Queue<T\>           | -                 |
| **说明**       | 自动改变容量      | 存储键值对                                            | 按键序存储元素       | 先进后出FILO | 先进先出FIFO        | 存储0/1的紧缩数组 |
| **排序性**     | 无序              | 无序                                                  | 按键排序             | FILO         | FIFO                | 无序              |
| **元素重复性** | 可重复            | 键唯一，值可重复                                      | 键唯一，值可重复     | 可重复       | 可重复              | 可重复            |
| **null 值**    | 可存储null        | 键不可为null，值可以                                  | 键不可为null，值可以 | 可存储null   | 可存储null          | 不可存储null      |
| **线程安全性** | 线程不安全        | 线程不安全                                            | 线程不安全           | 线程不安全   | 线程不安全          |                   |
| **线程安全类** | ImmutableList<T\> | ConcurrentDictionary<K,V\> or ImmutableDictionary<K,V\> | -                    |  ConcurrentStack<T\>        | ConcurrentQueue<T\> |     -              |
