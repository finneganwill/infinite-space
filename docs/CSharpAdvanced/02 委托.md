# 委托

## 一、委托概述

[委托](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types)是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。

**委托机制可以使方法作为参数进行传递。** 尤其在事件处理程序中经常使用。你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。

!!! Warning
	不要试图把委托理解为方法或类，委托就是委托，它的定位可以类比与结构体、枚举、类、接口等。

## 二、使用委托
### 01 声明委托
通过 `delegate` 关键字声明一个委托，如：
```csharp
public delegate void Del(string message);
```

!!! Note
	委托的声明可以在类内部，也可以在命名空间下，通常定义在类外部或命名空间下居多，但也要根据实际情况而定。

```csharp
namespace TestClass
{
    delegate void Del(string message); // 在命名空间下声明委托
    
	internal class A
	{
		// class body
	}
}
```

### 02 实例化委托
实例化委托也可以理解为绑定委托，即将一个方法绑定给委托，然后由委托执行。

实例化委托的方法有很多：

1. 通过new与签名匹配的方法实例化（上述示例的代码中采用该方法）；
2. 通过将方法分配给委托来实例化；
3. 通过匿名方法实例化委托；
4. 通过Lambda表达式实例化委托；

=== "new实例化"
	```csharp
	Del del = new Del(DelegateMethod);
	```

=== "方法分配实例化"
	```csharp
	Del del = DelegateMethod;
	```

=== "匿名方法实例化"
	```csharp
	Del del = delegate(string message){ Console.WriteLine(message); };
	```

=== "Lambda表达式实例化"
	```csharp
	Del del = message => { Console.WriteLine(message); };
	```

!!! Warning
	实例化委托时的方法应具有与委托相同的签名。

### 03 调用委托
对委托进行实例化后，委托会将对其进行的方法调用传递到该方法。 调用方传递到委托的参数将传递到该方法，并且委托会将方法的返回值（如果有）返回到调用方。 这被称为调用委托。 实例化的委托可以按封装的方法本身进行调用。

```csharp title="委托调用"
// 声明委托
public delegate void Del(string message);

// 创建方法
public static void DelegateMethod(string message)
{
    Console.WriteLine(message);
}

// 实例化委托：将方法绑定到委托
Del handler = DelegateMethod;

// 调用委托
handler("Hello World");

// Output：
// Hello World
```

### 04 委托实现方法作参数

由于 **实例化的委托是一个对象**，因此可以作为实参传递或分配给一个属性， 允许方法接受委托作为参数并在稍后调用委托。 这被称为异步回调，是在长进程完成时通知调用方的常用方法。 当以这种方式使用委托时，使用委托的代码不需要知道要使用的实现方法。

委托表示的是方法的引用，同时，委托的实例化是一个对象，因此委托机制能够将方法作为参数传递。如果想要将一个方法作为实参传入到另一个方法中，应当使用委托来完成。

下面通过一个示例来演示委托的用途：
```csharp title="方法作参数"
using System;  
using System.IO;

namespace DelegateAppl  
{  
   class PrintString  
   {  
      static FileStream fs;  
      static StreamWriter sw;  
      // 委托声明  
      public delegate void printString(string s);  
  
      // 该方法打印到控制台  
      public static void WriteToScreen(string str)  
      {  
         Console.WriteLine("The String is: {0}", str);  
      }  
      // 该方法打印到文件
      public static void WriteToFile(string s)  
      {
         fs = new FileStream("c:\\message.txt", FileMode.Append, FileAccess.Write);  
         sw = new StreamWriter(fs);  
         sw.WriteLine(s);  
         sw.Flush();  
         sw.Close();  
         fs.Close();  
      }
      // 该方法把委托作为参数，并使用它调用方法  
      public static void sendString(printString ps)  
      {
         ps("Hello World");  
      }
      static void Main(string[] args)  
      {
         printString ps1 = new printString(WriteToScreen);  
         printString ps2 = new printString(WriteToFile);  
         sendString(ps1);  
         sendString(ps2);  
         Console.ReadKey();  
      }
   }
}
```


## 三、合并委托
