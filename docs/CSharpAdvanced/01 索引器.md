# 索引器

## 一、索引器概述
索引器是类的特殊成员，索引器的存在允许类或结构体可以像数组一样进行索引。如：

数组的索引：
```csharp
string names = new string[2];
names[0] = "tom"; // 通过索引对数组赋值
var name = names[0]; // 通过索引从数组取值
```

索引器：
```csharp
SomeObject someObject = new SomeObject();
someObject["key"] = item; // 通过索引为某个对象的属性赋值
var item = someObject["key"]; // 通过索引获取某个对象的属性值
```

## 二、索引器的定义与调用

### 01 定义索引器
索引器使用 `this` 关键字定义，索引器与属性类似，在定义索引器时同样会用到 get 和 set 访问器，不同的是，访问属性不需要提供参数，而访问索引器则需要提供相应的参数。

示例1：
```csharp title="索引器定义示例1"
class IndexerTest
{
   // Declare an array to store the data elements.
   private string[] arr = new string[100];

   // Define the indexer to allow client code to use [] notation.
   public string this[int i]
   {
      get { return arr[i]; }
      set { arr[i] = value; }
   }
}

class Program
{
   static void Main()
   {
      var indexerTest = new IndexerTest();
      indexerTest[0] = "Hello, World";
      // 通过索引器访问属性
      Console.WriteLine(indexerTest[0]);
   }
}
// The example displays the following output:
// Hello, World.
```

示例2：
```csharp title="索引器定义示例2"
class Student
{
	private string name;
	private string sex;
	//索引器
	public string this[int index]//【访问修饰符】 数据类型 this【索引器类型 index】   语法格式
	{
		get
		{
			switch (index)
			{
				case 1:
					return name;
				case 2:
					return sex;
				default:
					throw new ArgumentOutOfRangeException("index");//抛出异常
			}
		}
		set
		{
			switch (index)
			{
				case 1:
					name = value;
					break;
				case 2:
					sex = value;
					break;
				default:
					throw new ArgumentOutOfRangeException("index");//抛出异常
			}
		}
	}
	public void Speak()
	{
		Console.WriteLine("我叫{0}，我是{1}生", this[1], this[2]);
	}
}
class Program
{
	static void Main(string[] args)
	{
		Student stu = new Student();
		//给索引器以数组的方式赋值
		stu[1] = "xxx";
		stu[2] = "男";
		stu.Speak();
		Console.ReadKey();
		
	}
}
```

!!!Note
	

### 02 表达式主体
索引器的 get 或 set 访问器包含一个用于返回或设置值的语句很常见。为了支持这种情况，表达式主体成员提供了一种经过简化的语法。

=== "C# 7.0"
	```csharp title="表达式主体简化索引器定义"
	class IndexerTest
	{
		// Declare an array to store the data elements.
		private string[] arr = new string[100];
		// Define the indexer to allow client code to use [] notation.
		public string this[int i]
		{
			get => arr[i];
			set => arr[i] = value;
		}
	}
	class Program
	{
		static void Main()
		{
			var indexerTest = new IndexerTest();
			indexerTest[0] = "Hello, World";
			// 通过索引器访问属性
			Console.WriteLine(indexerTest[0]);
		}
	}
	// The example displays the following output:
	//       Hello, World.
	```

=== "C# 6.0"
	```csharp title="表达式主体定义只读索引器"
	class IndexerTest
	{
		// Declare an array to store the data elements.
		private string[] arr = new string[100];
		// Define the indexer to allow client code to use [] notation.
		public string this[int i] => arr[i];
		// 只读索引器需要额外的方法添加元素
		public void Add(T value) 
		{ 
			if (nextIndex >= arr.Length) 
				throw new IndexOutOfRangeException(
				$"The collection can hold only {arr.Length} elements."
				); 
			arr[nextIndex++] = value; 
		}
	}
	class Program
	{
		static void Main()
		{
			var indexerTest = new IndexerTest();
			indexerTest[0] = "Hello, World";
			// 通过索引器访问属性
			Console.WriteLine(indexerTest[0]);
		}
	}
	// The example displays the following output:
	//       Hello, World.
	```

!!!Tip
	C#6.0引入表达式主体不允许 set 访问器，因此可以省略 get 实现只读索引器。但是 C# 7.0 后允许，get 和 set 访问器均可作为表达式主体成员实现，在这种情况下，必须使用 `get` 和 `set` 关键字。


## 三、索引器重载